
### 直接寻址表和散列表(哈希表)
**直接寻址表**就是用数组存放数据, 使用"索引"检索数据.
好处是速度很快, 但坏处也很明显, 需要准备一个很大的数组, 通常情况下, 这个很大的数组中很多都是没有使用的, 所以空间效率很低.

**哈希表**就是通过使用哈希函数, 将无限的寻址空间缩小到有限的空间内.
如果两个值对应的哈希值是相同的, 就需要处理**冲突**

冲突的解决方案有两种:
- 链接法
- 开放寻址法

#### 链接法
在表中的每个槽, 放一个队列, 如果有碰撞, 就在队列后添加.

#### 开放寻址法
修改哈希函数的输入, 让哈希函数同时接收两个参数: 索引值 + i.
其中i大于零, 小于表的容量. 让i从0增加到最大值, 知道出现一个哈希值对应的槽位没有值, 便可以使用这个槽位保存值.


哈希表利用了哈西函数的性质

### 哈希函数的性质
- 哈希函数的输入：无穷集
- 哈希函数的输出：有限集（MD5为2的64次方，SHA1为2的128次方）
- 哈希函数具有稳定性：给定一个输入，会有唯一的输出（但一个输出可能对应多个输入，这种情况叫碰撞，但概率很小）
- 哈希函数有均匀性：哈希函数能把输入均匀的映射到输出集
- 对于两个相似度很高的输入，哈希函数的输出也会分布的很均匀（即可能变化很大）

利用哈希函数的均匀性，可以对无穷集进行均匀的划分
每次得到哈希函数的输出时，对其进行求模运算，比如`mod(m)`，那么最后就可以将无穷集均匀的分配到`m`个不同的集合，且每个集合的长度差不多一致。

### 哈希表
利用上述均匀性的性质，可以把输入的`N`个数均匀的分为`m`分，那么每次查找的复杂度大概是`O(N/m)`，如果`N/m`变得很大的时候，可以考虑把`m`增大为`n>>m`，然后重新再算一次哈希表，这时复杂度便会降低到`O(N/n)`，这个重新计算哈希表的复杂度是`O(NlogN)`的，均摊到每一次操作，便是`O(logN)`的。
所以**理论上**哈希表的时间复杂度是`O(logN)`的
但实际操作中可以把最初的`m`设置的很大，最后的这个`logN`会很小。另外，想Java这样的虚拟机语言，JVM可以离线计算哈希表，从而进一步降低哈希表的复杂度。
	因此，我们常常说哈希表的复杂度是`O(1)`的。

