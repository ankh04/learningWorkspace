# 哈夫曼编码(Huffman Coding)
给定一个字符串`247242824`, 考虑怎么压缩这个字符串
一个数字就在ascii中占据8位,因此字符串`247242824`占据72bit

## 朴素方法
一个容易想到的方法是: 首先统计字符串中出现的所有字符,然后对每个字符做二进制编码,放到码表中,解码的时候按照码表译码即可
![[Pasted image 20220326213215.png]]
如上图所示, 根据码表, 可以把字符串`247242824`压缩成:
`00 01 10 00 01 00 11 00 01`, 这个字符串只有18个比特
压缩比是$\frac{18}{72}=\frac{1}{4}$


## 哈夫曼编码
上述算法看似不错,但是当字符串边长,每个`1-10`中每个数字都出现了,甚至ascii码中的所有字符都出现了,朴素方法的压缩比就不那么好看了.
原因在于朴素方法的码表对于每个字符都是用了定长的码字, 哈夫曼编码就是采用变长的码表

哈夫曼编码首先会对字符串中每个字符的词频做统计.
比如上述字符串中数字`2`的词频最高,对词频高的字符做短的编码,对词频底的做长编码,这样就能确保压缩效率始终比较高.
```ad-note
极端情况是:字符串中出现了很多种字符,且每种字符出现的概率相同,此时哈夫曼编码就退化成了朴素方法(但这种极端情况真的很少见)
```
哈夫曼编码的码表是这样的:
![[Pasted image 20220326214211.png]]
可是这样做了之后,在解码怎么知道哪些为应该按1的长度解码,哪些位应该按3的长度解码.
哈夫曼编码规定了码表中的每个码字都不能是其它码字的"前缀"

因此, 当对编码后的二进制流解码时,只需要从前往后查找,在码表中找到对应的码字后就可以确定对应的字符了. 因为码字不可能是其他码字的前缀, 因此在从前往后寻找的时候是不会有二义性的.

从树的角度来看, 哈夫曼编码的码表其实对应了一颗"右树", 该树的每一个叶子节点都代表一个字符
![[Pasted image 20220326214829.png]]
这也意味着只有树的底层才有两个叶子节点, 树的其他层都只有一个叶子节点.