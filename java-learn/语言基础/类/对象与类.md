# 对象与类
Pascal 语言的设计者 Niklaus Wirth 的著作《算法+数据结构=程序》( Algorithm + Data Structures = Programs )的书名充分反映了传统结构化程序设计的思想，即算法是第一位的，程序员应该先设计好算法，再考虑存储数据的适当方式。==而 [[OOP]] ( object-oriented programming )却调换了这个顺序，将数据放在第一位，然后再考虑操作数据的算法==。
## 类
类( class )是构造对象( object )的模板或蓝图，由类构造( construct )对象的过程称为创建对象的实例( instance )。
### 类之间的关系
类之间最常见的关系有：
- 依赖( 'uses-a' )

	依赖定义类A的过程中使用了类B。比如在定义学生`Student`类时，需要用到`String`类来表示学生名字。
	应该尽可能将相互依赖的类减少，如果依赖过多，往往会出现“牵一发而动全身”的情况，用行话来说这过程就是“去耦合”。
- 聚合( 'has-a' )

	
- 继承( 'is-a' )

	继承( inheritance )表示一个更特殊的类与一个更一般的类之间的关系，类A继承类B时，类A具有继承的类B的所有属性和方法。
	在 JAVA 中，所有的类都继承自一个“神通广大的类”，它就是`Object`类。
## 对象
对象有三个特征：
- 行为

	行为（method）表示对象可以完成哪些操作
- 状态

	状态（state）表示对象调用方法时，对象会如何响应
- 标识

	标识（identity）标识着两个状态和行为都相同的对象的不同

## 定义类
在 JAVA 中，定义类的方式如下：
```java
class ClassName {
	field_1
	field_2
	...
	constructor_1
	constructor_2
	...
	method_1
	method_2
}
```
对于一个 JAVA 源文件，`public` 类的名字必须与源文件名相同，另外，一个源文件只能有一个`public` 类。
##### field
对于`filed`即字段，最好都是用`private`修饰，这是为了保证类的封装性。
- final 字段
对于构造函数初始化后不再能改变的字段，可以用`final`字段修饰，即
```java
class Person {
	private final String name;
}
```
- 静态字段
对于普通字段，每个实例都会有自己的一个**副本**，而对于静态字段，所有实例都共享一个字段。
我们说：静态字段属于类，而不属于对象；普通字段属于对象

常见的用法是使用在`id`上
```java
class Person {
	private static int nextId = 1;
	private int id;
	public Person() {
		this.id = nextId++;
	}
}
```
在内置的`Math`类中也有静态字段，且该静态字段不可修改，用`final`修饰，它就是`Math.PI`
```java
class Math {
	public static final int PI = 3.1415926;
}
```
     -  由于是由`public`和`static`修饰的，所以可以直接由`Math.PI`访问
	- 又由于使用了`final`修饰，所以就算对外界直接暴露也不会被恶意修改
	- 又由于使用`static`修饰，对与每个`Math`实例，都共享同一个相同的`PI`，而不必每次都复制一个，这样可以节约空间。
##### constructor
- 构造器函数必须与类**同名**
- 每个类可以有**一个以上**的构造器（**仅**当没有提供任何构造器的时候，会自动生成无参数的构造器）
- 构造器可以由**任意**多个参数
- 构造器**没有**返回值
- 构造器**必须**伴随着`new`操作符一起调用（不能作为普通方法调用）
**构造器的形参与实参**
**形参**指的是声明函数中，指代传入参数的参数
实参指的是调用函数时，传入函数的参数
**构造器的显参与隐参**
显参指的是声明函数中，出现在函数名后面括号里的参数，和形参指代相同的意思
隐参则时指：
对于`Person`类中的方法`say`，
```java
public String say(String word) {
	return name + "says" + word;
}
```
该方法使用了显参`word`，以及类的字段`name`。
在调用这个方法的时候，编译器会将上述代码翻译成
```java
public String say(String word) {
	return Person.name + "says" + word;
}
```
这里的`Person`并不显示地出现在函数声明中，所以称为隐式参数。在方法中，可以使用`this`指代隐参。上述代码**还可以**改写成以下形式
```java
public String say(String word) {
	return this.name + "says" + word;
}
```
- 构造器的重载
构造器可以进行[[重载]]，
- 初始化过程
1. 默认字段初始化
	在声明中没有显示的设置初值，就会被自动赋值位默认值：数值类型位`0`，布尔类型位`false`，对象引用类型为`null`。
	依赖默认字段初始化并不是很好的实践，尤其对于对象引用类型来说，因为被默认赋值为`null`，所以对该对象的方法或属性进行访问时很容易引发错误。
2. 显示字段初始化
	在声明中显示地设置初值
```java
	class Person {
		private String name = "default";
	}	
```
   这里的初始化是在构造器初始化**前**完成的。
3. 构造器
	可以调用无参数的构造器对新对象进行初始化。
4. 调用另一个构造器
	可以使用`this`关键词的另一个用法，如果构造器的**第一行语句**形如`this(...)`，这个构造器将调用同一个类的另一个构造器
	```java
		public Person(string s) {
			this('Person #' + nextId++, s);
		}	
	```
5. 初始化块
	类的声明中可以包含任意多的代码块，在实例化对象的时候，这些代码块会按在类声明中出现的顺序执行。可以在这些代码块中初始化字段
下面给出上面五个步骤的前后顺序：
```mermaid
graph LR
	默认字段初始化 --> 显示字段初始化 --> 初始化块 --> 构造器
```
后面的初始化方式会覆盖之前的初始化结果。

##### method
对于一个私有变量，应该提供对应的**字段访问**方法和**字段修改**方法。
这样做的好处是:当内部结构发生变化的时候，可以只修改对应的字段访问方法和字段修改方法的实现，而不改变方法名，那么对于外界来说，仍可以按原来的方式访问该类的方法。这样就是一种很好的封装。
```ad-note
在字段访问方法中，应该避免直接返回private对象的引用，应该返回对象的复制。
如果返回对象的引用，这个private对象将可以被外界改变。
```
对外暴露的方法应该是`public`的，且应当保证方法名不变
不需要对外暴露的方法（比如一些内部的工具方法）则可以是`private`的，对`private`进行任意的修改都不会影响外界的使用。
- 静态方法
静态方法可以直接使用类名访问，比如`Person.getNextId()`
静态方法不能访问实例字段（即普通字段），只能访问静态字段，或者什么字段都不访问，比如`Math.pow(x,a)`就是什么字段都没有访问的静态方法。
静态方法也可以被实例对象访问。
静态方法可以用作工厂方法，常见的静态工厂方法有`LocalDate.now`和`LocalDate.of`，这是两种构造不同类型的`LocalDate`实例的方法，如果直接使用构造器构造的话，会有以下问题：
	  名称只能是类名，不是很好区分
	  构造的对象只能是类所对应的实例，而工厂方法这可以构造子类的实例（或者任意类的）

- main 方法
`main`方法应当是一个静态方法，一个类只能有一个`main`方法，可以直接使用
```java
java ClassName
```
来运行`ClassName`类中的`main`方法。可以用`main`方法对某个类进行单元测试。
- 方法的参数是按指传递的
即对于穿进来的参数，首先是复制一个副本，在方法内对这个副本做操作。
根据这一原则，我们可以得出以下结论
1. 方法修改不了基本类型的参数（即布尔型、数值型等，因为修改的是副本，对原始值没有影响）
2. 方法可以修改对象参数的属性（对象参数本来就是一个引用，引用的副本指向的是同一个对象）
3. 让对象参数指向新的对象（因为是副本，所以是让副本指向新对象，而不影响原对象参数）
例子：
```java
public void triple(int x) {
	x = 3 * x;
}// 不能让x变成三倍
```
```java
public void triple(Example e) {
	e.x = e.x * 3; // 假设e.x是public的
}// 可以改变e.x
```
