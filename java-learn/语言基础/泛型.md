# 泛型
泛型是对类型检查的一种拓展,它能让代码更易懂,也更安全.
不过需要注意的是,泛型其实是编译器进行的类型检查,编译后的结果中其实是不包含任何泛型语法的

使用泛型: 需要在相应的位置添加**声明泛型**的语法
## 泛型类
```java
public class Pair<T> {
	private T first;
	private T last;

	public Pair() {first = null; last = null;}
	public Pair(T first, T last) {this.first = first; this.last = last;}

	public T getFirst() {return first;}
	public T getLast() {return last;}

	public void setFirst(T value) {first = value};
	public void setLast(T last) {last = value};
}
```
可以发现类名后面多了一个尖括号语法`<T>`,这边是声明泛型的语法.
使用这个类时,可以这样用
```java
Pair<String> pair = Pair<String>();
Pair<String> pair2 = Pair<String>("haha", "hehe");
```
Java7之后,上述语句可以使用"菱形"语法简化
```java
Pair<String> pair = Pair<>();
Pair<String> pair2 = Pair<>("haha", "hehe");
```

## 泛型方法
```java
class ArrayAlg {
	// 注意,这个类并不是泛型类
	public <T> T getMiddle(T... a) {
		return a[a.length / 2];
	}
}
```
注意泛型方法声明泛型的位置.

我们可以这样使用这个泛型方法
```java
ArrayAlg arr = new ArrayAlg();
String middle = arr.<String>getMiddle("John", "Q.", "Public");
```
事实上,编译器往往能够根据方法的参数和返回值推断出对应的泛型,所以生产中往往写成下面的形式
```java
ArrayAlg arr = new ArrayAlg();
String middle = arr.getMiddle("John", "Q.", "Public");
```

## 类型变量的限定
在之前的例子中,我们只能在泛型方法直接使用a,而不能调用a上面的方法,这是因为我们不能确保传进来的a的类型具有我们期望的方法.
我们可以通过限定(bound)使泛型只接受特定的类型,从而让我们可以在泛型参数上调用方法
```java
class ArrayAlg {
	public <T extends Comparable> int compareFirstAndLast(Pair<T> pair) {
		return pair.getFirst.compareTo(pair.getLast);
	}
}
```
由于pair的方法`getFirst`返回的是`T`类型的,而`T`类型又限定了`Comparable`接口,因此`pair.getFirst`一定有`compareTo`方法.所以我们才可以放心大胆的在里边使用compareTo方法,且编译器不会报错.

## 类型擦除