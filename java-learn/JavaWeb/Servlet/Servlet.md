## 简述
Servlet = Server + applet
指的是服务器端的小程序
Servlet在Web应用中扮演"控制器"的角色(即把需要处理的事务和参数传递给Java业务代码,然后把业务代码返回的值抛出去)
![[Pasted image 20220213203428.png]]
## javax.Servlet
![[Pasted image 20220213214111.png]]
Servlet接口下有五个方法
我们常常继承HttpServlet这个类,这个类就实现了Servlet接口,继承关系如下图所示
![[Pasted image 20220213214425.png]]

常用的`doPost`,`doGet`,`service`方法都是定义在HttpServlet上边的.
一般来说,一个请求发过来,首先是service函数进行处理,HttpServlet类根据请求的方法名执行对应的`doPost`,`doGet`方法.
具体来说它们之间的关系如下
![[Pasted image 20220213220050.png]]

小结:
1) 继承关系： HttpServlet -> GenericServlet -> Servlet
2) Servlet中的核心方法： init() , service() , destroy()
3) 服务方法： 当有请求过来时，service方法会自动响应（其实是tomcat容器调用的）
            在HttpServlet中我们会去分析请求的方式：到底是get、post、head还是delete等等
            然后再决定调用的是哪个do开头的方法
            那么在HttpServlet中这些do方法默认都是405的实现风格-要我们子类去实现对应的方法，否则默认会报405错误
4) 因此，我们在新建Servlet时，我们才会去考虑请求方法，从而决定重写哪个do方法
## 生命周期
1） 生命周期：从出生到死亡的过程就是生命周期。对应Servlet中的三个方法：init(),service(),destroy()
加上构造器一共对应四个周期:

| 名称       | 时机                                                     | 次数               |
| ---------- | -------------------------------------------------------- | ------------------ |
| 创建对象   | 默认情况下:接受到第一次请求;修改启动顺序后:Web应用启动时 | 一次               |
| 初始化操作 | 创建对象之后   -> init                                   | 一次               |
| 处理请求   | 接受到请求   -> service                                  | 请求几次就触发几次 |
| 销毁操作   | Web应用卸载之前  -> destroy                              | 一次               |

2） 默认情况下：
	第一次接收请求时，这个Servlet会进行实例化(调用构造方法)、初始化(调用init())、然后服务(调用service())
	从第二次请求开始，每一次都是服务
	当容器关闭时，其中的所有的servlet实例会被销毁，调用销毁方法
3） 通过案例我们发现：
	- Servlet实例tomcat只会创建一个，所有的请求都是这个实例去响应。
	- 默认情况下，第一次请求时，tomcat才会去实例化，初始化，然后再服务.这样的好处是什么？ 提高系统的启动速度 。 这样的缺点是什么？ 第一次请求时，耗时较长。
	- 因此得出结论： 如果需要提高系统的启动速度，当前默认情况就是这样。如果需要提高响应速度，我们应该设置Servlet的初始化时机。
4） Servlet的初始化时机：
	- 默认是第一次接收请求时，实例化，初始化
	- 我们可以通过\<load-on-startup\>来设置servlet启动的先后顺序,数字越小，启动越靠前，最小值0
	- 也可以通过注解,设置WebServlet里的loadOnStartup值为1(默认值为-1)
5） Servlet在容器中是：单例的、线程不安全的
	- 单例：所有的请求都是同一个实例去响应
	- 线程不安全：一个线程需要根据这个实例中的某个成员变量值去做逻辑判断。但是在中间某个时机，另一个线程改变了这个成员变量的值，从而导致第一个线程的执行路径发生了变化
	- 我们已经知道了servlet是线程不安全的，给我们的启发是： 尽量的不要在servlet中定义成员变量。如果不得不定义成员变量，那么不要去：1.不要去修改成员变量的值 2.不要去根据成员变量的值做一些逻辑判断
## 会话状态
1) http是无状态的
- http默认是没有状态的,即没办法区分不同的请求用户,也无法知道同一个用户请求的先后状态.
- 无状态带来的现实问题：第一次请求是添加商品到购物车，第二次请求是结账；如果这两次请求服务器无法区分是同一个用户的，那么就会导致混乱
- 通过会话跟踪技术来解决无状态的问题。
2) 会话跟踪技术
- 客户端第一次发请求给服务器，服务器获取session，获取不到，则创建新的，然后响应给客户端
- 下次客户端给服务器发请求时，会把sessionID带给服务器，那么服务器就能获取到了，那么服务器就判断这一次请求和上次某次请求是同一个客户端，从而能够区分开客户端
- 常用的API：
	  request.getSession() -> 获取当前的会话，没有则创建一个新的会话
	  request.getSession(true) -> 效果和不带参数相同
	  request.getSession(false) -> 获取当前会话，没有则返回null，不会创建新的
	  session.getId() -> 获取sessionID
	  session.isNew() -> 判断当前session是否是新的
	  session.getMaxInactiveInterval() -> session的非激活间隔时长，默认1800秒
	  session.setMaxInactiveInterval()
	  session.invalidate() -> 强制性让会话立即失效
3) 一个session对应一个作用域,不同session之间不能共享数据
## 服务器内部转发以及客户端重定向
1. 服务器内部转发 : request.getRequestDispatcher("...").forward(request,response);
	  - 一次请求响应的过程，对于客户端而言，内部经过了多少次转发，客户端是不知道的
	  - 地址栏没有变化
![[04.服务器内部转发.png]]

2. 客户端重定向： response.sendRedirect("....");
	  - 两次请求响应的过程。客户端肯定知道请求URL有变化
	  - 地址栏有变化
![[05.客户端重定向.png]]