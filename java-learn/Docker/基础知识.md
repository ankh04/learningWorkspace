## 虚拟化技术
##### 虚拟化技术是什么?
就是模拟一个虚拟的软件运行环境,且不同的运行环境之间是隔离的.
##### 虚拟化技术解决了什么问题?
虚拟化技术出现之前,一台机器上只有一个操作系统,多个应用程序在同一个运行环境运行,多个程序之间会可能会遭遇冲突(比如端口号冲突).
虚拟化技术打破了操作系统和硬件的相互依赖,可以提供强大的安全和故障隔离,且虚拟机是独立于硬件的.
总的来说,虚拟化技术可以讲一台计算机虚拟为多台逻辑计算机,每个逻辑计算机之间相互独立,可以运行不同的操作系统,从而提高计算机的资源利用率.
##### 虚拟化技术的发展
最开始的虚拟化技术是完全基于软件的,即通过代码的方式对应用程序的指令进行翻译,这种做法效率很低.

后来随着虚拟化热潮,AMD,Intel等芯片公司都提供了硬件级别的虚拟化技术,从此虚拟化的效率大大提升.


## 虚拟化技术分类
**按照虚拟化技术与硬件和操作系统之间的关系,可以分为两种:**
- 全虚拟化技术
![[Pasted image 20220220141957.png]]
- 半虚拟化技术
 ![[Pasted image 20220220142029.png]]
全虚拟化技术与半虚拟化技术的区别在于操作系统是否经过定制.
全虚拟化技术不需要操作系统做任何更改,对操作系统发过来的指令"照单全收"的翻译
而半虚拟化技术则需要对操作系统做一些修改,将操作系统的一些指令进行优化,方便下层的VMM更快速的翻译
半虚拟化技术会比全虚拟化技术的速度更快,但由于需要定制系统,开发难度会很大,再加上现在的操作系统日新月异,半虚拟化技术是比较少见的.

**按虚拟化层(Hypervisor)的位置也可以分为两类**
- 寄居架构
![[Pasted image 20220220142522.png]]
在操作系统之上建立的虚拟化层.
优点是:简单,便于实现,只需要和操作系统api打交道
缺点是:依赖于操作系统,原来的操作系统也会占用资源
例子:Parallel Desktop, VMware Workstation都是常见的寄居架构的虚拟化产品
- 裸金属架构
![[Pasted image 20220220142822.png]]
在硬件之上建立虚拟化层
优点是:资源占用少,更灵活
缺点是:开发困难,需要和硬件打交道,需要自己造虚拟机内核
例子:VMware ESXI Server

## Docker
Docker是[[PAAS]]提供商 dotCloud 基于 [[Linux Container]](LXC) 的高级容器引擎,基于GO语言遵从 Apache 2.0 开源.

#### 容器 和 虚拟机
![[Pasted image 20220220144332.png]]
对于传统的虚拟机而言,对每个应用都提供了一套完整的操作系统.
对于容器而言,它复用了宿主操作系统,由Docker为应用提供对应的运行环境.

虚拟机提供了完整的隔离,但每次提供一套完整的操作系统会导致资源的浪费.
容器技术提供了更轻量化的运行环境,但由于是复用同一个操作系统,安全性可能会不如传统虚拟机.

#### Docker运行流程
![[Pasted image 20220220145314.png]]
Docker是C/S架构的,客户端发送类似于`docker pull xx`的命令给Docker服务器,Docker首先找本地是否有容器,如果没有就向官方仓库索取.之后再启动应用程序,通过Docker服务器与宿主机进行交互,最后将结果返回给客户端.

假设有个应用,我们需要将它运行两份,分别为应用A和应用B
对于传统的虚拟机,两个应用可能是这样的关系
![[Pasted image 20220220145637.png]]
可以发现这里面有很多重复的部分,于是Docker设想能不能复用同一份操作系统
![[Pasted image 20220220145828.png]]
但是这样会带来一个问题,两个应用程序公用一个操作系统,隔离性就很差了(比如两个应用用着同一个资源,可能会带来很多隐患)
![[Pasted image 20220220145949.png]]
于是Docker在应用层下面加了一个空白层,应用只能感知到空白层以上的东西,比如应用A和应用B都对空白层说它们要使用资源C,空白层对上会把资源C给到它们,但是对下空白层可能创建了资源D和资源E,把资源D当做资源C给到应用A,把资源E当做资源C给到应用B,但应用A和应用B都以为它们拿到的是资源C.
其实关键就是空白层,于是可以讲空白层以下的部分抽取出来,作为静态资源,需要创建应用的时候,就创建对应的应用和空白层就好.于是就有了以下的结构
![[Pasted image 20220220150431.png]]
空白层以下的部分抽取出来叫做应用A的镜像,空白层以上的便是镜像创建出来的容器.

另外,Docker的镜像是按**层**分级的.