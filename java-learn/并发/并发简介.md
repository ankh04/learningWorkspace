# 简介
## 进程
早期的计算机不包含操作系统, 以个程序从头到尾执行, 而且每次只能执行一个程序, 这对于昂贵的计算机资源是一种浪费.

后来出现了操作系统, 从而让计算机能够一次运行多个程序. 
每个程序都运行在单独的"进程"中, 每个进程相当于一台冯诺依曼计算机, 每条被执行的指令都有对应的"下一条"指令, 这里的"下一条指令"由操作系统管理, 需要注意的是, 并不是说"单核计算机"能同时处理多个进程, 而是操作系统对进程进行管理, 让计算机以很快的速度交替执行不同的进程, 看起来好像是计算机在同时处理多个进程(当然, 后来出现了多核CPU, 计算机就可以"真的"同时处理多个进程了)

在一个进程中, 指令都是"串行"地运行的, 但是串行运行效率不高(可以试着联系日常, 在烧水的时候, 往往会看看手机啥的, 这就是并行的思想), 于是就出现了线程

## 线程
线程允许在==同一个进程==中同时存在多个程序控制流, 多个线程会==共享==进程范围内的资源, 但每个线程都有==自己的程序计数器(PC)==, ==栈==, ==局部变量表==. 

线程可以看成一种==轻量级的进程==, 大多数现代操作系统都以==线程==为基本的调度单位.
由于同一个进程中的所有线程可以共享资源, 因此就需要实现==更细粒度==的数据共享机制.

## 协程
协程可以看成一种==轻量级的线程==.

## 进程和线程的区别
线程是进程内部的概念.
进程的资源是操作系统分配的,
线程的资源是进程分配的

## 为什么要使用并发
 人们发现很难再单独通过提高CPU的主频来提高CPU性能, 于是人们开始考虑建造多核CPU, 为了更好的利用CPU的多核架构, 人们开始考虑程序的并行性.

### 线程的优势
- 发挥多核处理器的能力
- 简化并发编程模型
- 简化异步事件
在单线程, 如果需要==不停顿==的处理多个套接字请求, 需要使用复杂的==非阻塞I/O==, 而若使用线程, 可以在每个线程中使用简单的阻塞I/O.
- 更灵敏的GUI

### 线程带来的风险
- 多个线程同时访问/使用一个数据的时候会引发数据安全性问题 ---> 通过同步方法解决
- 活跃性问题
	- 如果通过同步方法保证了数据安全性, 那么可能存在线程A等待线程B的情况, 如果线程B执行很久, 就会带来性能问题. 另一方面, 如果遇到线程A在等待线程B, 且线程B在等待线程A的情况, 会形成死锁, 类似于单线程应用里的无限循环. 这样的问题称为==活跃性问题==
- 性能问题
	- 多线程应用一定会比单线程应用快么?🤔 ---> 不一定
	- 多线程由于需要进行上下文切换操作(Context Switch), 从而一定会有一定程度上的运行时开销.
	- 另一方面, 同步机制也会抑制编译器优化, 导致额外的性能开销
