# 虚拟机栈
虚拟机栈中有两种常见的[[抽象数据结构]](ADT): 栈和堆
栈是**运行时**的数据结构,解决的是程序如何执行,数据该如何处理的问题
堆是**存储时**的数据结构,解决的是数据放在哪里,怎么放的问题

### 概述
每一个线程对应一个虚拟机栈
虚拟机栈的生命周期和线程相同,线程被销毁后,虚拟机栈也被销毁.
虚拟机栈由**栈帧**组成,每个栈帧对应一个Java方法的调用

虚拟机栈只接受两种操作: 出栈和入栈 (因此虚拟机栈没有什么优化空间,GC并不会对虚拟机栈进行垃圾回收)

虚拟机栈的访问速度是很快的,仅次于程序计数器.

可以对vm做`-Xss`配置更改虚拟机栈的大小
![[Pasted image 20220322163409.png]]
![[Pasted image 20220322163404.png]]

### 栈帧
在一个活跃的线程中,在某一个特定的时间点上,只会有一个活动的**栈帧**,称之为**当前栈帧**,对应方法是**当前方法**,对应类是**当前类**.
执行引擎只针对当前栈帧进行操作
如果当前方法调用了其他方法,则新的栈帧就会被创建出来,称为新的栈帧

### 运行中的栈帧
不同线程的栈帧是不能相互引用的

若有方法A调用了方法B,在方法B返回之际,会把方法B的返回结果传递给方法A对应的栈帧,接着方法B的栈帧就会被销毁,使得方法A的栈帧成为当前栈帧.

### 栈的内部结构
栈的内部可以划分成六块:`局部变量表`,`操作数栈`,`动态链接`,`方法返回地址`,`方法的调用`,`附加信息`
#### 局部变量表
- 局部变量表表现为一个数组,有索引,和索引对应的值.
- 局部变量表中只存放**8种基本数据类型**,**对象引用**(而不是对象本身,是对象的地址),**返回的地址**
- 局部变量表是在虚拟机栈中的,这意味着它是每个线程占一份的,不存在数据共享,因此是线程安全的.
- 局部变量表的大小是在编译期间确定下来的
- 局部变量表最基本的单位是slot,其中一个slot占32位,double和float类型的数据占用两个slot,其他基本数据类型只占用1个slot
![[Pasted image 20220322165504.png]]
如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this，会存放在index为0的slot处，其余的参数表顺序继续排列. 
如果当前帧是静态方法创建的,则不会有this,也就又不会有上图中关于this的slot
slot是可以重复使用的,如果一个局部变量过了它的作用域,它所占用的slot就会被标记为空,之后的其他变量可以利用这个slot
- 局部变量表与当前方法的生命周期相同,当方法调用结束后,会随之销毁
**垃圾回收**
被局部变量引用的数据和对象都不会被垃圾回收
#### 操作数栈
在方法执行的过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈/出栈
主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间
**栈顶缓存技术**
由于操作数是存储在内存中，频繁的进行内存读写操作影响执行速度，将栈顶元素全部缓存到物理CPU的寄存器中，依此降低对内存的读写次数，提升执行引擎的执行效率
#### 动态链接

每一个栈帧内部都包含一个指向运行时常量池中，该帧所属方法的引用
#### 方法返回地址
有两种方法返回的方式
1. 正常执行完成
2. 出现未处理异常,非正常退出
无论哪种方式退出，方法退出后，都会返回该方法被调用的位置。方法正常退出时，调用者的PC计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。
返回指令包括
`ireturn`:返回值是boolean, byte, char, short, int时使用
`lreturn`: 返回值是long时使用
`dreturn`: 返回值是double时使用
`areturn`: 返回值是引用类型时使用
`return`: 没有返回值时使用
#### 方法的调用
先阐述两个概念**静态链接**和**动态连接**
在编译器领域,**静态**通常表示编译的时候就能确定的,**动态**通常表示运行的时候才能确定的.

所以,静态链接表示: 如果某个方法在编译的时候就能确定,并且在执行的时候不会改变,这时就会将调用方的**符号引用**转化为**直接引用**

而动态链接表示无法在编译时确定的方法,只在能在运行时将调用的方法符号引用转化为直接引用.

与静态链接相似的概念有: 早期绑定, 非虚方法
与动态链接相似的概念有: 晚期绑定, 虚方法(对应C++里的virtual函数)

那么常见的静态链接方法有哪些呢?
- 静态方法,static
- 私有方法,private
- final方法
- 实例构造器
- 父类方法(通过super调用的父类方法)

在字节码中, 有四种对应的指令
- invokestatic: 调用静态方法
- invokespecial: 调用私有方法, 父类方法
- invokevirtual: 调用虚方法(通常public void name()这样的方法都是虚方法,虚方法是java的默认属性)
- invokeinterface: 调用接口方法(接口方法一定是动态的,所以是虚方法)


**虚方法表**
在多态的java代码里, 一个实例执行一个方法往往需要往继承链上找方法, 如果很频繁的进行这样的操作会很消耗资源, 于是JVM为每个类建立了一个虚方法表, 表中存放着各个方法的实际入口, 就不用每次挨个找了.

#### 附加信息
允许携带与Java虚拟机实现相关的一些附加信息，例如对程序调试提供支持的信息。不确定有，可选情况

