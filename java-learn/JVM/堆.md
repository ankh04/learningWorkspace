# 堆
## 概述
#### 存什么?
"**几乎**"所有对象都存储在堆区, 数组都存在堆区
数组和对象都以引用的方式存储在**栈**中

#### 什么时候创建?
一个JVM对应一个堆, 堆区在JVM启动的时候创建, 堆区的大小可以可以通过 JVM 参数设置.

#### 堆区的唯一性
由于一个JVM对应一个堆, 一个JVM里的所有线程都共享同一个堆区(但需要注意, 堆区里有一个缓冲区 TLAB, 这个位置是每个线程一份的).

#### 堆区的连续性
堆在**物理**上可以不是连续的, 但是在**逻辑**上是连续的(即在JVM虚拟机内部看来, 堆的地址是连续的, 但在操作系统看来堆区的地址其实是不连续的, 造成这种差别的原因是因为虚拟做了相应的接口)

#### 回收
在方法结束后, 对象不会马上销毁, 只会在垃圾回收时进行清除
堆是垃圾回收的重点

#### 结构
分为 `新生区` `养老区` `元空间(Java7之前叫永久区)`
新生区又分为: `Eden区` `Survivor区`
Survivor区又分为两个区, 只有一个区会存储数据

#### 指令
- 查看GC回收详情
`-XX:+PrintGCDetail`
- jvisualvm

## 设置堆内存大小
- `-Xms:1G` 表示起始堆区大小为1G
- `-Xmx:1G` 表示最大堆区大小为1G(通常把最大堆区和起始堆区设成一样的,可以减少GC的性能消耗)

- 默认行为:
	- 初试大小为: 电脑物理内存的1/64
	- 最大大小为: 电脑屋里内存的1/4

- 指令
	- jps命令: 查看当前正在运行的Java进程
	- jstat命令: `jstat -gc 进程号`, 参看JVM在GC时的统计信息


## 新生代和老年代
几乎所有的对象都是在新生代的Eden区创建出来的, 大部分的对象都是==朝生夕死==的, 所以大部分的对象都在Eden区被回收了.
若没有被回收, 会进入Survivor区, 在Survivor区也会进行回收操作, 当一个对象在Survivor区存在了一段时间后, 就会进入老年代, 老年代进行垃圾回收的概率会小很多.

Java中, 新生代和老年代的空间比例默认是: `1 : 2`, 可以通过`-XX:NewRatio=2`来设置自己的比例.

在新生代中, Eden区和Survivor区的默认比例是: `8 : 1`, 可以通过`-XX:SurvivorRatio=8`来设置自己的比例.

## 对象在堆空间的创建过程
![](https://picture-bed-1301848969.cos.ap-shanghai.myqcloud.com/20220402115510.png)
![]()
1. 对象首先试图在Eden区创建, 如果放得下, 到2, 否则到3
2. 分配内存空间
3. 进行Young GC(Minor GC), 这次GC会释放Eden区的一些空间, 并且会对Survivor区也进行GC, 并交换Survivor区. 
4. 如果进行GC后, Eden区放得下该对象, 到2, 否则到5
5. 如果到这一步, 说明该对象很大, 就考虑老年代区是否可以放得下, 如果放得下, 到2, 否则到6
6. 对老年代进行Full GC(Major GC),
7. 如果进行完FGC后, 老年代的空间放得下了, 到2, 否则报错OOM(Out Of Memory)

对于Survivor区有以下特征:
当Survivor区中的对象的年龄达到阈值时(默认是15), 会进入老年代

## MinorGC, MajorGC
每次进行GC的时候, 用户的代码逻辑就会暂停, 进入垃圾回收线程进行垃圾回收, 这个过程称作==STW(Stop The World)==

### MinorGC的特点
当Eden区满时, 会进行MinorGC, 但是Survivor区满时并不会进行MinorGC.
MinorGC是针对新生代的 Eden区 和 Survivor区 进行垃圾回收的.
Java中的对象大部分都是朝生夕死的, 所以进行MinorGC的频率非常高

### MajorGC的特点
当老年代空间不足时会进行MajorGC
MajorGC触发时, 经常会伴随至少一次MinorGC
MajorGC比MinorGC的速度慢很多, 并且STW持续的时间会更长

## 如果不对堆进行分区, 可以么?
当然可以, 但这意味着每次进行垃圾回收时需要对整个堆空间进行扫描, 耗时会很长.

## 堆区的安全性问题
堆区是线程共享的, 任何线程都可以到堆区共享数据.
这就回带来线程不安全的问题, 因此JVM在堆区中开辟了一块空间TLAB, 这块空间是每个线程独一份的, 是线程安全的.

在多个线程同时分配内存时, 可以用TLAB作为缓冲区, 从而避免线程不安全问题.

## 所有对象一定分配在堆区么?
不是
JVM会对变量做逃逸分析, 如果变量没有发生逃逸, 就会直接在栈空间上分配空间.