# 作用域
变量是用来存储值的, 并且之后可以对这个变量进行访问或修改, 这是几乎所有编程语言的基本功能.

但引入变量又会带来一些问题:
- 变量住在哪里?
- 程序如何找到它们?

于是编程语言设计者会设计一套规则用来解决上面的问题, 这套规则就称为`作用域`.

### 声明一个变量并初始化的过程
在这里先用一个简单的例子来引入作用域, 对于代码`var a = 1`, 会按照以下过程处理:
1. 解析到`var a`, 编译器会询问==作用域==是否已经有一个该名称的变量, 如果已经有了, 该声明会被忽略, 调到2. 如果没有, 就会在==作用域==声明一个新的变量, 并命名为a
2. 解析到`a=2`, 编译器会把这行代码翻译成机器码, 编译器的工作到此为止. 接下来是引擎的工作, 当运行到`a=2`时, 引擎会询问==作用域==是否有一个名称为a 的变量, 如果是, 引擎就会对这个变量赋值, 否则, 会向外层==作用域==寻找.
3. 如果外层==作用域==找到了, 就对其赋值; 如果没有, 就继续向外层找;  如果一直找到最外层, 也就是==全局作用域==还是没找到, 按是否处于严格模式分为两种情况, 如果是严格模式, 到4, 否则到5
4. 如果是严格模式, 就报错
5. 如果不是严格模式, 引擎会自动创建一个名称为a的变量, 并对其赋值

在上述过程中, 我们发现编译器和引擎都会和作用域打交道, 可见作用域对于变量来说是很重要的.

### LHS查询和RHS查询
在例子`var a = 1`中, 引擎对变量a的查询过程称为`LHS查询`(LeftHandSearching)

而对于这个例子`console.log(a)`, 引擎对变量a的查询为`RHS查询`(RightHandSearching)

首先可以找到两者的共同点, 两个例子都存在"赋值"操作, 第一个例子是显示的赋值, 第二个例子是对形参的赋值: `形参a = 实参a`.
只不过在第一个例子中, a是在等号左边, 而在第二个例子中, a在等号右边

值得注意的是, 不能单纯把RHS查询当做等号右边的, LHS当成等号左边的, 很多情况下并没有等号作为参照物, 比如下面的例子:
```javascript
function foo(a) {
	console.log(a)
}

foo(1)
```
- 第一次LHS查询: 发生在`foo(1)`, 引擎运行到这里需要知道函数变量foo的位置, 因此进行一次LHS查询
- 第二次LHS查询: 发生在`function foo(a)`, 对于这个函数来说, 它有一个形参, 我们把2作为实参传入进来的时候, 会进行一次隐式的赋值操作, 引擎需要知道形参a的位置, 因此进行一次LHS查询
- 第一次RHS查询: 发生在`console.log(a)`, 在给console.log传参的时候, 需要知道a到底存放了什么, 因此需要进行一次RHS查询

### 作用域的嵌套
考虑以下代码
```JavaScript
function foo(a) {
	console.log(a + b)
}

var b = 2 
foo(2) // => 4
```
作用域是以代码块分隔的, 在函数`foo`中, 可以发现除了形参a之外并没有声明其他变量, 因此在执行到`a+b`时, 会向上层作用域RHS查找`b`, 找到之后最终返回4.

### 为什么需要区分RHS和LHS
之所以要区分这个, 是因为js的特殊机制导致了LHS和RHS的逻辑是不同的.
比如对于下面的代码
```JavaScript
function foo(a) {
	console.log(a + b)
}

foo(2) // => ReferenceError
```
这个例子和第二个例子很接近, 只不过全局作用域下没有了b的声明, 因此在进行RHS查询查找变量b的时候会找不到, 就会报错了, 我们有以下结论
- 当RHS查询失败时, 会报ReferenceError错误

对于LHS查询又是怎样呢, 其实我们已经在[声明一个变量并初始化的过程]章节中讨论过了, 会分为两种情况处理
- 处于严格模式下, 当LHS查询失败时, 会报ReferenceError错误
- 处于非严格模式下, 当LHS查询失败时, 会创建新的全局变量并返回


### 词法作用域
上面一直在提作用域, 那么作用域到底是怎么划分的呢?

在JavaScript 中作用域由语法块划分.

但是JavaScript 还提供了两种方法来"逃离"作用域, 分别是`with`和`eval`.

这两种方式都会影响编译器的优化, 有时候可能还会带来让人迷惑的错误, 因此最好避免使用这两个方法.