根据端到端原理, 应该在尽量高的层次提供可靠服务. 事实情况也是如此, 传输层以下的网络层, 链路层, 物理层都不提供可靠性.

因此, 传输层的基本假设有两点:
- 是它的底层信道是不可靠的
- 底层信道不会对分组重新排序

## rdt1.0
首先考虑最简单的情况, 底层信道是完全可靠的, 不会有任何信息丢失.

对于发送端来说, 只需要不断接收上层传来的数据, 包装之后发送出去
对于接收端来说, 需要不断接收信道传来的数据, 然后提取其中的数据传递给上层

## rdt2.0(停等协议)
在这种情况下, 我们假设信道会让信息有比特位的损坏

类比人类对话, 当其中一方没有听清楚时, 会发出"请再说一遍"的消息, 期待对方重传消息.
rdt就是在网络中实现上述操作.

对于发送端来说有两步:
- 接收上层传来的数据, 包装之后发送出去
- 等待ACK或NAK
	- 如果是ACK, 继续接收上层传来的数据, 包装之后发送出去
	- 如果是NAK, 重新发送数据

对于接收端来说有两步:
- 接收信道传来的数据, 提取数据
- 检查数据是否损坏
	- 如果损坏发送NAK
	- 如果没损坏发送ACK

## rdt2.1
rdt存在一个问题, 那就是ACK/NAK信号也可能损坏.

解决这个问题有很多思路, TCP采用的是在ACK信号上加上一个比特位, 叫做*序号*

接收端和发送端会在两个状态之间跳转, 从而保证了不会向上层多传递重复消息

## rdt3.0
实际情况中, 信道不止会有比特位的损坏, 还会有丢包的情况.

rdt3.0就是用来解决上述问题的, rdt3.0加入了定时器, 如果在发送了一个分组后过了一段时间都没有收到ACK, 就会触发定时器, 再进行一次发送.

这里的关键是定时器的等待时间, 这个等待时间至少为网络的最大时延. 然而网络中两个端点之间的最大时延是很难确定的.

## 停等协议的问题
rdt2.0 - rdt3.0都是停等协议, 也就是说在发送一个分组后, 必须等到一个ACK/NAK之后才能处理下一次行动, 中间都在等待.

然后网络传输时间往往会比发送端的发送时间慢得多, 因此发送方大部分的时间都耗在等待上了, 这样的效率是很低的.

我们希望让发送方能不间断的发送分组, 但这带来了一个问题, 如何区分返回的ACK/NAK呢?

有两种方案: *回退N步* *选择重传*
### 回退N步
首先会规定一个*窗口长度N*, 让发送方最多只能发送未收到ACK/NAK消息的分组N个.
至于为什么要设定这个窗口长度, 原因有两个:
- 流量控制
- 拥塞控制

为了区分ACK/NAK, 会在rdt3.0的基础上使用更多的比特位作为序号.

对于发送端来说:
- 如果第N个分组延时, 或丢失, 则从第N个分组往下重新发送消息

对于接收端来说
- 如果第N个分组没有收到, 却收到了N+1的分组, 便把N之后的分组都丢弃.

### 选择重传
回退N步的问题在于, 如果发送了100个分组, 其中第3个分组出错了, 那么从4-100的分组都会被丢弃(也就是说浪费了).

选择重传的接收端只会让出错的分组重传, 而对于之后的分组, 会先缓存起来, 从而避免了浪费.
