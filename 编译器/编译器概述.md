## 编译器的成就
- 现代词法分析器是通过正则语言的理论建立的
- LR语法使用正则语言执行句柄识别, 进而驱动了一个移进归约语法分析器
- 数据流分析巧妙有效地将[[格理论]]应用到程序分析
- 代码生成则巧妙的运用了近似算法

## 编译器遇到的困难
后端中的`指令调度`和`寄存器分配`都是[[NP问题#NPC问题|NP完全问题]],


## 程序语言与自然语言的区别
自然语言允许二义性, 而程序语言

## 编译器
把源程序转化为目标程序(通常是汇编语言)的工具, 称为编译器

`源到源的编译器`: 将源程序转化为另一种语言的(比如C)源程序, 称为源到源编译器.

## 解释器
将源程序直接转化为`结果`的工具, 称为解释器.
代表有: Perl, Scheme, APL

## 编译器和解释器的结合
Java就是将编译器和解释器结合的典型例子: `javac`就是一个编译器, 它把java源代码转化成[[字节码]], 字节码是一种紧凑的表示, 可以减少Java程序的下载时间, 而JVM就是一个解释器, 它将执行字节码直接得出结果.
而许多JVM又实现了一个运行时的编译器, 称为JIT(just-in-time)编译器, 它可以将==频繁使用的==字节码转化成运行速度更快的底层[[计算机本机码]].


## 编译器的基本原则
1. 编译器必须保证被编译程序的语义
2. 编译器必须以某种可察觉的方式改进输入程序


# 编译器结构
### 两阶段编译器
![](https://picture-bed-1301848969.cos.ap-shanghai.myqcloud.com/20220406121109.png)
前端专注于==理解==源程序
后端专注于将程序==映射==到目标机.

前端和后端通过==中间表示(IR)==交互.

### 三阶段编译器
在实际应用中, 为了让编译器生成的代码运行更快, 通常还会在编译器中添加一个叫做==优化器==的结构
![](https://picture-bed-1301848969.cos.ap-shanghai.myqcloud.com/20220406121741.png)

### 更详细的编译器结构
![](https://picture-bed-1301848969.cos.ap-shanghai.myqcloud.com/20220406121854.png)

前端的时间复杂度会低一些, 而后端由于涉及到指令选择, 指令调度等任务, 时间复杂度都会超过$O(n)$, 所以编译时间的大头都在后端(以及优化)上.