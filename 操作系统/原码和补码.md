人们希望计算机能够识别正数和负数, 也就是说希望计算机能表示有符号数.
原码和补码都是计算机表示有符号数的编码方式.

## 原码
原码添加一个*符号位*来表示正数和负数

但是这样做有如下缺点:
- 加法器需要额外的步骤识别符号位, 硬件设计起来复杂
- 会有负零和正零(这会带来很多麻烦, 比如正零和负零是否相等? 什么时候会得出正零? 什么时候会得出负零?)

## 补码
补码的灵感来源于以下思想:
- 计算机中表示一个数的位数是**有限**的
- 用计算的思想理解负数: `-1 = 0 - 1`


假设我们使用的是一个八位的CPU, 会这样表示0和1:
0 --- 0000 0000
1 --- 0000 0001

那么0减1会得到什么呢? 在加法器看来, 0 减 1 会发生一系列的**借位**行为, 所以最后的结果会是:
0 - 1 = -1 ----> 1111 1111

这样做的好处是没有更改硬件行为, 只是改变了编码方式, 我们就可以表示 -1 了.

```ad-note
计算机只是计算机, 它只会计算.
在计算机看来 1111 1111 就是一串电平序列, 本身不表示任何信息.

但在人类看来, 如果它表示的是一个无符号数, 那么它就是 255 , 如果它表示的是一个有符号数, 那么它就是 -1
```
#### 补码的性质
- 正数的补码是以**有限个连续0**开头的, 负数的补码是以**有限个连续1**开头的

**反码**: 按位取反得到的结果, 表示为$\bar x$.

- 注意到-1的补码是全1. 而一个数的反码和自己相加一定是全1. 所以有以下公式:
$$
x+\bar x = -1
$$
所以当我们需要求一个数$x$的的相反数的补码时, 可以用这个公式: $-x = \bar x + 1$.
即先求出该数的反码, 然后加1就得到了该数相反数的补码. (这个只是人类的方法😒, 计算机直接使用加法器就可以求出来了)