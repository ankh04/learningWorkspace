## 什么是链接?
链接(linking)就是将各种代码和数据片段收集并组合成单一文件(可执行文件)的过程.

链接可以发发生在: **编译时, 加载时, 运行时**

## 链接解决了什么问题?
链接解决的是软件开发上的困难. 
链接让*分离编译*成为可能.

我们可以将一个大型应用程序分割成不同的模块, 分别对模块进行编译, 然后通过链接器合成一个可执行文件.(从而避免了在一个文件中编写大量的代码, 这样既不便于开发, 也不容易发现bug)

## 目标文件
可重定向目标文件:
![](https://picture-bed-1301848969.cos.ap-shanghai.myqcloud.com/20220508214829.png)


可执行目标文件:
上面的去掉 rel 节就是可执行目标文件了

目标文件的信息可以通过指令`readelf`查看


## 链接的分类
在程序员编写程序的时候, 希望把精力主要集中在业务代码上, 尽量减少与操作系统提供的系统调用直接打交道.

为了方便程序员开发, 程序员往往会使用对应语言提供的标准库.

对于 c 语言来说有 stdio 库, 对于 rust 语言来说有 std 库, 对于 Java 语言来说有 java.core 库.

上面的这些库都是*静态库*,  对于 c 语言来说, 是以`.a`结尾的文件.

这种在*编译时*进行链接的操作就是: **静态链接**.
而在*运行时*进行链接的操作是: **动态链接**

## 静态链接
静态链接主要完成两个任务:
- 符号解析 --- 将每个符号()与定义关联
- 重定位     ---  将符号定义与内存位置关联

### 符号解析
符号分为*全局符号*和*局部符号*
而全局符号又分为*本模块定义的全局符号*和*其他模块定义的全局符号*

在 .symtab 节中存放着符号表.

通过查看 elf 信息, 可以看到:
![](https://picture-bed-1301848969.cos.ap-shanghai.myqcloud.com/20220509202857.png)

如果多个文件之间没有重名的问题, 符号解析会很直接简单. 如果有重名, 则链接器会按照一定的规则进行解析.

### 重定位
在重定位之前生成的 .o 文件是*可重定位目标文件*, 这种文件是不能直接执行的.

经过重定位之后的文件, 是*可执行目标文件*, 这种文件才是可以直接运行的.

重定位主要由三步工作:
- 将所有模块的 .data 节合并成一个 .data 节, 并把新的 .data 节的地址更新到每个模块
- 对每个符号的运行时内存地址做更新
- 对更新后的地址的引用做更新


执行完上述操作后, 就可以得到一个可执行目标文件了, 这时候这个文件里就没有 `.rel` 节.


## 执行时发生了什么?
在输入下面的指令执行可执行目标文件时:
```shell
$ ./main
```
操作系统的*加载器*将把目标文件的内容从==磁盘复制到内存==, 这个过程叫做*加载*.

然后执行 `_start` 的内容. 对于 c 语言来说, 编译器会自动插入一段启动函书在这个位置, 它负责初始化执行环境, 然后调用用户层的 main 函数.
