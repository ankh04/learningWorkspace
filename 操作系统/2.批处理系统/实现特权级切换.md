**特权级切换**
在执行 Trap 类指令的时候, CPU 会执行一个中断, 并进行*环境切换*.
具体来说即使把当前上下文保存在某个地方(某个内存块, 或内核维护的栈), 等 Trap 结束后, 再把上下文恢复.

还有一个特殊的寄存器也需要保存上下文, 那就是保存Trap前所处的特权级的寄存器.

特权级的切换一部分由==硬件==实现, 一部分由==软件==实现

S特权级相关的CSR
![](https://picture-bed-1301848969.cos.ap-shanghai.myqcloud.com/20220507120938.png)


**特权级切换时硬件的工作**
==当执行 Trap 类指令时:==
-   `sstatus` 的 `SPP` 字段会被修改为 CPU 当前的特权级（U/S）。
-   `sepc` 会被修改为 Trap 处理完成后默认会执行的下一条指令的地址。
-   `scause/stval` 分别会被修改成这次 Trap 的原因以及相关的附加信息。
-   CPU 会跳转到 `stvec` 所设置的 Trap 处理入口地址，并将当前特权级设置为 S ，然后从Trap 处理入口地址处开始执行。
==当Trap完毕准备返回时==
-   CPU 会将当前的特权级按照 `sstatus` 的 `SPP` 字段设置为 U 或者 S ；
-   CPU 会跳转到 `sepc` 寄存器指向的那条指令，然后继续执行。

**特权级切换时软件的工作**
==1. 保存上下文==
操作系统自己维护了一个*内核栈*, 与应用程序使用的*内核栈*是独立的(为了安全性)

当执行trap类指令时, 操作系统会保存:
- `x0~x31`的通用寄存器
- sstatus
- spec
虽然硬件会自动保存CSR寄存器, 但在Trap嵌套的情况下, sstatus/spec 可能会被覆盖掉, 因此操作系统会自己保存一份.