早期的计算机都是使用打孔纸带使用的.
程序员需要写程序, "输入"程序, 传递纸带等操作, 导致计算机的使用效率极低.

之后人们考虑设计可以像==流水线般==执行多个程序的*操作系统*, 从而出现了*批处理系统*

用力过猛的MULTICS


## 特权机制
因为批处理操作系统也是程序, 我们需要确保在批处理操作系统上的程序不会影响到操作系统本身.

特权机制需要硬件和软件的配置


为确保操作系统的安全, 对应用程序而言, 有两方面的限制:
- 应用程序不能访问任意的地址空间
- 应用程序不能执行可能破坏计算机系统的指令


当应用程序需要调用操作系统提供的功能时, 会使用`ecall`, `eret`指令.


RISC-V有四种特权级别: U S H M

H特权级RISC规范还没设定好
M级别--RustSBI 启动引导程序
S级别-- 操作系统
U级别 -- 应用程序


使用ecall调用的功能和调用函数是不一样的==控制流==, 是*异常控制流*

RISCV的异常表
![](https://picture-bed-1301848969.cos.ap-shanghai.myqcloud.com/20220502205551.png)


**特权级切换**
在执行 Trap 类指令的时候, CPU 会执行一个中断, 并进行*环境切换*.
具体来说即使把当前上下文保存在某个地方(某个内存块, 或内核维护的栈), 等 Trap 结束后, 再把上下文恢复.

还有一个特殊的寄存器也需要保存上下文, 那就是保存Trap前所处的特权级的寄存器.

特权级的切换一部分由==硬件==实现, 一部分由==软件==实现

**特权级切换时硬件的工作**
==当执行 Trap 类指令时:==
-   `sstatus` 的 `SPP` 字段会被修改为 CPU 当前的特权级（U/S）。
-   `sepc` 会被修改为 Trap 处理完成后默认会执行的下一条指令的地址。
-   `scause/stval` 分别会被修改成这次 Trap 的原因以及相关的附加信息。
-   CPU 会跳转到 `stvec` 所设置的 Trap 处理入口地址，并将当前特权级设置为 S ，然后从Trap 处理入口地址处开始执行。
==当Trap完毕准备返回时==
-   CPU 会将当前的特权级按照 `sstatus` 的 `SPP` 字段设置为 U 或者 S ；
-   CPU 会跳转到 `sepc` 寄存器指向的那条指令，然后继续执行。

**特权级切换时软件的工作**
==1. 保存上下文==
操作系统自己维护了一个*内核栈*, 与应用程序使用的*内核栈*是独立的(为了安全性)

当执行trap类指令时, 操作系统会保存:
- `x0~x31`的通用寄存器
- sstatus
- spec
虽然硬件会自动保存CSR寄存器, 但在Trap嵌套的情况下, sstatus/spec 可能会被覆盖掉, 因此操作系统会自己保存一份.