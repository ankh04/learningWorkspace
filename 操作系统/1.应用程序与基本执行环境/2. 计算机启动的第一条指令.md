## 处理器执行第一条指令的位置
我们知道计算机主要由*处理器*, *物理内存*, *IO外设*组成. 计算机启动之后, 就需要处理器从读取指令, 执行, 和存储. 从开机到关机处理器和物理内存一直在持续这样的交互动作.

从处理器的视角来看, 物理内存就是一个大数组, 处理器通过*地址*访问内存中的数据. 与数据结构中的数组不同, 这个地址并不是从 0 开始的, 这个起始地址由 *bios* 决定, 在我们之后要用到的 [[Qemu]] 模拟器中, 我们会使用 `0x80000000` 作为起始地址.

## Qemu 模拟器的启动流程
我们使用以下的命令来启动我们的虚拟机:
```shell
$ qemu-system-riscv64 \
    -machine virt \
    -nographic \
    -bios ../bootloader/rustsbi-qemu.bin \
    -device loader,file=target/riscv64gc-unknown-none-elf/release/os.bin,addr=0x80200000
```

指令中, 我们启动了一个名为 `virt` 的机器, 它的物理内存的起始地址是 `0x80000000`.
`bios` 参数表示将 rustsbi-qemu.bin (这是一个bootloader) 载入到起始地址.
`device` 参数表示将 `os.bin` (这个是我们的系统内核) 载入到`0x80200000` 上.


在上述过程中, 一共经历了三个阶段: 
1. 这个阶段由固化在 Qemu 内的一小段汇编程序负责, 此时会执行位于 `0x1000` 位置的指令, 经过一些简单的指令后会转到 `0x80000000` 上, 进入第二阶段. 因此, 这里的起始地址 `0x80000000` 是写死在 qemu 中的, 如果不更改 qemu 的源码, 是无法更改的.
2. 这个阶段会执行我们放入起始地址的 bootloader 代码. 即`rustsbi-qemu.bin`. 它会对计算机进行一些初始化工作, 然后跳转到代码中规定的`0x80200000`上.(在实际的操作系统中, 是不需要这个约定的, bios 可以将物理磁盘中的操作系统加载到物理内存中, 因为整个加载过程都是 bios 负责的, 它自然知道操作系统在内存中的位置)
3. 程序计数器来到`0x80200000`上, 开始执行操作系统内核的代码.