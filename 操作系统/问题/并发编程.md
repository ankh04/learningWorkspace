## 什么是并发? 并发的应用场景有哪些?
如果逻辑控制流在时间上有重叠, 那么这些逻辑就是并发的(concurrent).

==应用场景==
操作系统内核为了能够同时处理多个应用程序, 会有*内核层面的并发*

*应用层面也会有并发*: 
- 一个服务器同时服务多个客户端
- 现代视窗系统
- 多核计算机上的并行运算

## 现代操作系统构造并发程序的方式有哪些?
 - 通过进程, 也就是直接使用*内核*提供的并发机制
 - 通过I/O多路复用
 - 通过线程

## 基于进程的并发有哪些特点?
以一个Web服务器(父进程)为例, 每次接受到一个请求之后就向内核请求一个新的进程(子进程).

==优点==
- 基于进程的并发编程代码量小 (因为都交给内核去做了)
- 每个进程都有独立的虚拟内存空间, 因此不同的服务之间不会互相影响.

==缺点==
- 父进程需要及时关闭不使用的子进程, 不然会很容易占满内存
- 进程间共享状态需要用IPC, 开销会很高

## 基于I/O多路复用的并发有哪些特点?
以一个Web服务器为例, 一个服务器只需要维护一个进程.
*事件驱动设计* : 这个进程类似于一个状态机, 根据逻辑流进入不同的状态, 从而达到并发的目标

==优点==
- 共享数据变得很容易(因为共用了一个进程的上下文)
- 事件驱动的设计给服务器程序员带来了更多自由度

==缺点==
- 代码量大, 复杂
- 事件驱动的服务器容易受到恶意客户端的攻击
- 不能充分利用多核处理器

## 基于线程的并发有哪些特点?
基于线程的并发融合了基于进程的和基于I/O多路复用的方法.

在一个进程中会有多个线程的程序, 每个线程都有自己的上下文, 即**线程ID, 栈, 栈指针, 程序计数器, 通用寄存器**
所有的线程都共享所属进程的 **堆, 静态代码, 数据, 库, 打开的文件**

线程相对于进程的优势:
- 线程的上下文比进程的上下文小, 切换起来更快
- 线程之间共享数据更方便(可以通过进程的虚拟内存共享)

## 什么叫做线程逻辑流的互斥? 什么叫做同步?
可以把线程的执行过程分割成好几个段, 然后在n维的笛卡尔空间中画出来. 下面以两个线程为例, 画出了*进度图*
![](https://picture-bed-1301848969.cos.ap-shanghai.myqcloud.com/20220614203911.png)

如果线程1的某些逻辑不能和线程2的某些逻辑同时出现, 就说线程1和线程2在这些区域上*互斥*, 在进度图中可以表示成:
![](https://picture-bed-1301848969.cos.ap-shanghai.myqcloud.com/20220614204107.png)

保证轨迹线为安全的方式就是*同步*

## 如何使线程同步? 什么是互斥锁?
Edsger Dijkstra提出了经典的*信号量*用来同步线程. 
信号量是一个非负整数 s
通过两个对信号量的操作 P 和 V 来同步线程.

如果信号量 s 只有两种可能的值 0 和 1, 那么这个信号量称为*二元信号量*
二元信号量又称为*互斥锁(mutex lock)*
在互斥锁上执行P操作就是*加锁*
在互斥锁上执行V操作就是*解锁*
一个互斥锁加了锁但还没有解锁的状态称为*占用了这个互斥锁*

## 什么是死锁? 怎么用进度图表示死锁?
程序死锁表示每个线程都在等待其他线程执行一个*根本不会发生的V操作*

在进度图上, 如果两个不安全区有重叠(角, 边的重叠也算), 那么就有可能发生死锁.

